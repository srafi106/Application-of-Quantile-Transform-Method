## Standard Normal Variate Generation by Quantile Transform 
Method (q_rnorm)
## Generate one data set which contains n observations ##
library(rootSolve)
rinorm<-function(n)
{
  u<-runif(n,.5)
  a<-b<-numeric(n)
  for (i in 1:n)
  {
    f<-function(x)
    {
      1-((1/sqrt(2*pi))*(exp(-
                               (x^2)/2)/(0.226+0.64*x+0.33*sqrt(x^2+3))))-u[i]
    }
    x<-uniroot.all(f,c(0,10))
    v=runif(1)
    a[i]=ifelse(v<=.5,x,-x)
  } 
  return(a)
}
## Generate k number of data sets (X and Y) for both methods 
where each data set contains n observations ##
k=1000; n=320
## Use seed number to generate each sample from the same 
place (useful to reproduce results)
seed=50
X<-matrix(0,k,n)
Y<-matrix(0,k,n)
for (i in 1:k)
{
  set.seed(seed+i)
  X[i,]<-rinorm(n)
  Y[i,]<-rnorm(n)
}

## Calculating Type 1 Error (whether two empirical 
distributions are the same)
size_test<-function(X,Y)
{ 
  r<-nrow(X)
  count<-0
  for (j in 1:r)
  {
    ks<-ks.test(X[j,],Y[j,])
    ind<-ifelse(ks$p>=0.05,0,1)
    count<-count+ind
  }
  return(count/r)
}
size_test(X,Y)
## Calculate average bias, MSE and coverage probability of mean 
and variance parameter
statis<-function(X,Y)
{
  r<-nrow(X)
  col<-ncol(X)
  n<-(col-1)
  # mean and variance for sample generated by inverse
  transform method
  ime_x<-apply(X,1,mean)
  iva_x<-apply(X,1,var)
  # mean and variance for sample generated by available
  method
  me_y<-apply(Y,1,mean)
  va_y<-apply(Y,1,var)
  # bias for mean (mb), variance (vb), mse for mean and
  variance (mmse, vmse) under inverse method
  imb<-ivb<-immse<-ivmse<-imcp<-ivcp<-numeric(r)
  mb<-vb<-mmse<-vmse<-mcp<-vcp<-numeric(r)
  sd_ime_x<-sd(ime_x)
  sd_me_y<-sd(me_y)
  
  z=qnorm(.975) 
  chi_up<-qchisq(0.025,n)
  chi_ll<-qchisq(0.975,n) 
  for (j in 1:r)
  {
    # statistics under inverse method
    imb[j]<-ime_x[j]-0
    ivb[j]<-iva_x[j]-1
    immse[j]<-imb[j]^2
    ivmse[j]<-ivb[j]^2
    # do for icp as well for mean and variance
    # coverage probability for mean
    iul<-ime_x[j]+z*sd_ime_x
    ill<-ime_x[j]-z*sd_ime_x
    if (0>ill & 0<iul) imcp[j]<-1 
    # coverage probability for variance for inverse
    transform method
    iv_ul<-(n*iva_x[j])/chi_up
    iv_ll<-(n*iva_x[j])/chi_ll
    if (1>iv_ll & 1<iv_ul) ivcp[j]<-1
    # statistics under available method 
    mb[j]<-me_y[j]-0
    vb[j]<-va_y[j]-1
    mmse[j]<-mb[j]^2
    vmse[j]<-vb[j]^2
    # do for cp as well
    ul<-me_y[j]+z*sd_me_y
    ll<-me_y[j]-z*sd_me_y
    if (0>ll & 0<ul) mcp[j]<-1
    # Coverage probability for variance for available
    method 
    v_ul<-(n*va_y[j])/chi_up
    v_ll<-(n*va_y[j])/chi_ll
    if (1>v_ll & 1<v_ul) vcp[j]<-1
  }
  list(iamb=mean(imb),iavb=mean(ivb),iammse=mean(immse),iavmse
       =mean(ivmse),iamcp=mean(imcp),irmse=sqrt(mean(immse)+mean(iv
                                                                 mse)),iavcp=mean(ivcp),amb=mean(mb),avb=mean(vb),ammse=mean(
                                                                   mmse),avmse=mean(vmse),rmse=sqrt(mean(mmse)+mean(vmse)),amcp
       =mean(mcp),avcp=mean(vcp))
}
## Return all the outputs
statis(X,Y)
## code for computing time to generate sample under q_rnorm and 
rnorm ##
isimu<-function(n)
{
  rinorm(n)
}
simu<-function(n)
{
  rnorm(n)
}
n=20000
system.time(isimu(n*1000))/1000
system.time(simu(n*1000))/1000
## Code for checking randomness visually ##
library(TSA); par(mfrow = c(2, 2)) # Set up a 2 x 2 plotting 
space
# Create the loop.vector (all the columns)
loop.vector <- 1:4
sample.size<-c(20,200,2000,20000)
seed=5
for (i in loop.vector) 
{
  # Loop over loop.vector
  set.seed(seed+i)
  x<-isimu(sample.size[i])
  # Plot acf of x
  j=sample.size[i]
  acf(x,lag=100,main=paste("n=", j))
}
## Code for testing randomness through Ljung-Box Test ##
n=20; set.seed(6)
x1<-isimu(20)
Box.test (x1, lag = 3, type = "Ljung")
n=200; set.seed(7)
x1<-isimu(200)
Box.test (x1, lag = 12, type = "Ljung")
Box.test (x1, lag = 20, type = "Ljung")
n=2000; set.seed(8)
x1<-isimu(2000)
Box.test (x1, lag = 20, type = "Ljung")
Box.test (x1, lag = 37, type = "Ljung")
Box.test (x1, lag = 87, type = "Ljung")
Box.test (x1, lag = 95, type = "Ljung")
n=20000; set.seed(9)
x1<-isimu(20000)
Box.test (x1, lag = 4, type = "Ljung")
Box.test (x1, lag = 30, type = "Ljung")
Box.test (x1, lag = 31, type = "Ljung")
Box.test (x1, lag = 49, type = "Ljung")
Box.test (x1, lag = 54, type = "Ljung")
Box.test (x1, lag = 63, type = "Ljung")
Box.test (x1, lag = 92, type = "Ljung")
## Overlaying the true pdf on sample histogram ##
par(mfrow = c(2, 2)) # Set up a 2 x 2 plotting space
set.seed(12)
x1<-isimu(20)
Box.test (x1, lag = 100, type = "Ljung")
hist(x1,freq=F,breaks=4,main=paste("n=", 20),xlab="x values")
xx<-seq(-3,3,0.01)
lines(xx,dnorm(xx),type="l")
set.seed(7); x2<-isimu(200)
Box.test (x2, lag = 100, type = "Ljung")
hist(x2,breaks=15,freq=F,main=paste("n=", 200),xlab="x values")
xx<-seq(-3,3,0.01)
lines(xx,dnorm(xx),type="l")

set.seed(8); x3<-isimu(2000)
Box.test (x3, lag = 100, type = "Ljung")
hist(x3,breaks=15,freq=F,main=paste("n=", 2000),xlab="x values")
xx<-seq(-3,3,0.01)
lines(xx,dnorm(xx),type="l")
set.seed(9); x4<-isimu(20000)
Box.test (x4, lag = 100, type = "Ljung")
hist(x4,breaks=15,freq=F,main=paste("n=", 20000),xlab="x values")
xx<-seq(-3,3,0.01)
lines(xx,dnorm(xx),type="l")
#######################################################################
## Code for generating sample from Gamma density using quantile 
transform method
library(rootSolve)## R code for shape parameter 3 ##
g3=function(n,b)
{
  v=c(); u=runif(n)
  for(i in 1:n)
  {
    gc=function(x)
    {
      1-exp(-x*b)*((1+(b*x/1)+((b*x)^2)/2))-u[i]
    } 
    v[i]=uniroot.all(gc,c(0,1000))
  }
  return(v)
}
## For other shape parameter values code will be very similar to 
previous one ##
## Code for producing Summary statistics and graphs are very 
similar to r_norm ##
## Original codes will be given to reader whenever authors are 
requested ## 
## Chi square variate generation by quantile Transform Method 
(q_rchisq) ##
## Generate one data set which contains n observations ##

library(rootSolve)
ichisq<-function(n,k,l=0)
{
  x = c()
  u = runif(n)
  for (i in 1:n)
  {
    x[i]<-(k+l)*(1-
                   (2*(k+2*l))/(9*(k+l)^2)+qnorm(u[i])*sqrt((2*(k+2
                                                                *l))/(9*(k+l)^2)))^3
  }
  return(x)
}
## For other parameter values code will be very similar to 
previous one ##
## Code for producing summary statistics and graphs are very 
similar to r_norm ##
## Original codes will be given to reader whenever authors are 
requested ##

